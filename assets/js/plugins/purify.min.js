(function(e) {
  const t = typeof window === 'undefined' ? null : window; if (typeof define === 'function' && define.amd) { define(() => e(t)); } else if (typeof module !== 'undefined') { module.exports = e(t); } else { t.DOMPurify = e(t); }
}(function e(t) {
  const r = function(t) { return e(t); }; r.version = '0.7.4'; if (!t || !t.document || t.document.nodeType !== 9) { r.isSupported = false; return r; } let n = t.document; const a = n; const i = t.DocumentFragment; const o = t.HTMLTemplateElement; const l = t.NodeFilter; const s = t.NamedNodeMap || t.MozNamedAttrMap; const f = t.Text; const c = t.Comment; const u = t.DOMParser; if (typeof o === 'function') { const d = n.createElement('template'); if (d.content && d.content.ownerDocument) { n = d.content.ownerDocument; } } const m = n.implementation; const p = n.createNodeIterator; const h = n.getElementsByTagName; const v = n.createDocumentFragment; const g = a.importNode; let y = {}; r.isSupported = typeof m.createHTMLDocument !== 'undefined' && n.documentMode !== 9; const b = function(e, t) { let r = t.length; while (r--) { if (typeof t[r] === 'string') { t[r] = t[r].toLowerCase(); }e[t[r]] = true; } return e; }; const T = function(e) { const t = {}; let r; for (r in e) { if (e.hasOwnProperty(r)) { t[r] = e[r]; } } return t; }; let x = null; const k = b({}, ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'svg', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmuliscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mpspace', 'msqrt', 'mystyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', '#text']); let A = null; const w = b({}, ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'accent-height', 'accumulate', 'additivive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'mode', 'min', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'surfacescale', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'y', 'y1', 'y2', 'z', 'zoomandpan', 'accent', 'accentunder', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'display', 'displaystyle', 'fence', 'frame', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']); let E = null; let S = null; let M = true; let O = false; let L = false; let D = false; const N = /\{\{[\s\S]*|[\s\S]*\}\}/gm; const _ = /<%[\s\S]*|[\s\S]*%>/gm; let C = false; let z = false; let R = false; let F = false; let H = true; let B = true; const W = b({}, ['audio', 'head', 'math', 'script', 'style', 'svg', 'video']); const j = b({}, ['audio', 'video', 'img', 'source']); const G = b({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']); let I = null; const q = n.createElement('form'); const P = function(e) { if (typeof e !== 'object') { e = {}; }x = 'ALLOWED_TAGS' in e ? b({}, e.ALLOWED_TAGS) : k; A = 'ALLOWED_ATTR' in e ? b({}, e.ALLOWED_ATTR) : w; E = 'FORBID_TAGS' in e ? b({}, e.FORBID_TAGS) : {}; S = 'FORBID_ATTR' in e ? b({}, e.FORBID_ATTR) : {}; M = e.ALLOW_DATA_ATTR !== false; O = e.ALLOW_UNKNOWN_PROTOCOLS || false; L = e.SAFE_FOR_JQUERY || false; D = e.SAFE_FOR_TEMPLATES || false; C = e.WHOLE_DOCUMENT || false; z = e.RETURN_DOM || false; R = e.RETURN_DOM_FRAGMENT || false; F = e.RETURN_DOM_IMPORT || false; H = e.SANITIZE_DOM !== false; B = e.KEEP_CONTENT !== false; if (D) { M = false; } if (R) { z = true; } if (e.ADD_TAGS) { if (x === k) { x = T(x); }b(x, e.ADD_TAGS); } if (e.ADD_ATTR) { if (A === w) { A = T(A); }b(A, e.ADD_ATTR); } if (B) { x['#text'] = true; } if (Object && 'freeze' in Object) { Object.freeze(e); }I = e; }; const U = function(e) { try { e.parentNode.removeChild(e); } catch (t) { e.outerHTML = ''; } }; const V = function(e) {
    let t,
      r; try { t = (new u()).parseFromString(e, 'text/html'); } catch (n) {} if (!t) { t = m.createHTMLDocument(''); r = t.body; r.parentNode.removeChild(r.parentNode.firstElementChild); r.outerHTML = e; } if (typeof t.getElementsByTagName === 'function') { return t.getElementsByTagName(C ? 'html' : 'body')[0]; } return h.call(t, C ? 'html' : 'body')[0];
  }; const K = function(e) { return p.call(e.ownerDocument || e, e, l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT, () => l.FILTER_ACCEPT, false); }; const J = function(e) { if (e instanceof f || e instanceof c) { return false; } if (typeof e.nodeName !== 'string' || typeof e.textContent !== 'string' || typeof e.removeChild !== 'function' || !(e.attributes instanceof s) || typeof e.removeAttribute !== 'function' || typeof e.setAttribute !== 'function') { return true; } return false; }; const Q = function(e) {
    let t,
      r; re('beforeSanitizeElements', e, null); if (J(e)) { U(e); return true; }t = e.nodeName.toLowerCase(); re('uponSanitizeElement', e, { tagName: t }); if (!x[t] || E[t]) { if (B && !W[t] && typeof e.insertAdjacentHTML === 'function') { try { e.insertAdjacentHTML('AfterEnd', e.innerHTML); } catch (n) {} }U(e); return true; } if (L && !e.firstElementChild && (!e.content || !e.content.firstElementChild)) { e.innerHTML = e.textContent.replace(/</g, '&lt;'); } if (D && e.nodeType === 3) { r = e.textContent; r = r.replace(N, ' '); r = r.replace(_, ' '); e.textContent = r; }re('afterSanitizeElements', e, null); return false;
  }; const X = /^data-[\w.\u00B7-\uFFFF-]/; const Y = /^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; const Z = /^(?:\w+script|data):/i; const $ = /[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; const ee = function(e) {
    let r,
      a,
      i,
      o,
      l,
      s,
      f,
      c; re('beforeSanitizeAttributes', e, null); s = e.attributes; if (!s) { return; }f = { attrName: '', attrValue: '', keepAttr: true }; c = s.length; while (c--) { r = s[c]; a = r.name; i = r.value; o = a.toLowerCase(); f.attrName = o; f.attrValue = i; f.keepAttr = true; re('uponSanitizeAttribute', e, f); i = f.attrValue; if (o === 'name' && e.nodeName === 'IMG' && s.id) { l = s.id; s = Array.prototype.slice.apply(s); e.removeAttribute('id'); e.removeAttribute(a); if (s.indexOf(l) > c) { e.setAttribute('id', l.value); } } else { if (a === 'id') { e.setAttribute(a, ''); }e.removeAttribute(a); } if (!f.keepAttr) { continue; } if (H && (o === 'id' || o === 'name') && (i in t || i in n || i in q)) { continue; } if (D) { i = i.replace(N, ' '); i = i.replace(_, ' '); } if (A[o] && !S[o] && (G[o] || Y.test(i.replace($, '')) || o === 'src' && i.indexOf('data:') === 0 && j[e.nodeName.toLowerCase()]) || M && X.test(o) || O && !Z.test(i.replace($, ''))) { try { e.setAttribute(a, i); } catch (u) {} } }re('afterSanitizeAttributes', e, null);
  }; var te = function(e) { let t; const r = K(e); re('beforeSanitizeShadowDOM', e, null); while (t = r.nextNode()) { re('uponSanitizeShadowNode', t, null); if (Q(t)) { continue; } if (t.content instanceof i) { te(t.content); }ee(t); }re('afterSanitizeShadowDOM', e, null); }; var re = function(e, t, n) { if (!y[e]) { return; }y[e].forEach(e => { e.call(r, t, n, I); }); }; r.sanitize = function(e, n) {
    let o,
      l,
      s,
      f,
      c; if (!e) { e = ''; } if (typeof e !== 'string') { if (typeof e.toString !== 'function') { throw new TypeError('toString is not a function'); } else { e = e.toString(); } } if (!r.isSupported) { if (typeof t.toStaticHTML === 'object' || typeof t.toStaticHTML === 'function') { return t.toStaticHTML(e); } return e; }P(n); if (!z && !C && e.indexOf('<') === -1) { return e; }o = V(e); if (!o) { return z ? null : ''; }f = K(o); while (l = f.nextNode()) { if (l.nodeType === 3 && l === s) { continue; } if (Q(l)) { continue; } if (l.content instanceof i) { te(l.content); }ee(l); s = l; } if (z) { if (R) { c = v.call(o.ownerDocument); while (o.firstChild) { c.appendChild(o.firstChild); } } else { c = o; } if (F) { c = g.call(a, c, true); } return c; } return C ? o.outerHTML : o.innerHTML;
  }; r.addHook = function(e, t) { if (typeof t !== 'function') { return; }y[e] = y[e] || []; y[e].push(t); }; r.removeHook = function(e) { if (y[e]) { y[e].pop(); } }; r.removeHooks = function(e) { if (y[e]) { y[e] = []; } }; r.removeAllHooks = function() { y = []; }; return r;
}));
